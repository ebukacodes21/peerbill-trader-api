// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: order.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
  username, escrow_address, user_address, order_type, crypto, fiat, crypto_amount, fiat_amount, rate, bank_name, account_number, account_holder, duration
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, username, escrow_address, user_address, order_type, crypto, fiat, crypto_amount, fiat_amount, bank_name, account_number, account_holder, rate, is_accepted, is_completed, is_rejected, is_received, duration, created_at
`

type CreateOrderParams struct {
	Username      string         `db:"username" json:"username"`
	EscrowAddress string         `db:"escrow_address" json:"escrow_address"`
	UserAddress   string         `db:"user_address" json:"user_address"`
	OrderType     string         `db:"order_type" json:"order_type"`
	Crypto        string         `db:"crypto" json:"crypto"`
	Fiat          string         `db:"fiat" json:"fiat"`
	CryptoAmount  float64        `db:"crypto_amount" json:"crypto_amount"`
	FiatAmount    float64        `db:"fiat_amount" json:"fiat_amount"`
	Rate          float64        `db:"rate" json:"rate"`
	BankName      sql.NullString `db:"bank_name" json:"bank_name"`
	AccountNumber sql.NullString `db:"account_number" json:"account_number"`
	AccountHolder sql.NullString `db:"account_holder" json:"account_holder"`
	Duration      time.Time      `db:"duration" json:"duration"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.Username,
		arg.EscrowAddress,
		arg.UserAddress,
		arg.OrderType,
		arg.Crypto,
		arg.Fiat,
		arg.CryptoAmount,
		arg.FiatAmount,
		arg.Rate,
		arg.BankName,
		arg.AccountNumber,
		arg.AccountHolder,
		arg.Duration,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.EscrowAddress,
		&i.UserAddress,
		&i.OrderType,
		&i.Crypto,
		&i.Fiat,
		&i.CryptoAmount,
		&i.FiatAmount,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountHolder,
		&i.Rate,
		&i.IsAccepted,
		&i.IsCompleted,
		&i.IsRejected,
		&i.IsReceived,
		&i.Duration,
		&i.CreatedAt,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT id, username, escrow_address, user_address, order_type, crypto, fiat, crypto_amount, fiat_amount, bank_name, account_number, account_holder, rate, is_accepted, is_completed, is_rejected, is_received, duration, created_at FROM orders
WHERE id = $1
AND order_type = $2
LIMIT 1
`

type GetOrderParams struct {
	ID        int64  `db:"id" json:"id"`
	OrderType string `db:"order_type" json:"order_type"`
}

func (q *Queries) GetOrder(ctx context.Context, arg GetOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrder, arg.ID, arg.OrderType)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.EscrowAddress,
		&i.UserAddress,
		&i.OrderType,
		&i.Crypto,
		&i.Fiat,
		&i.CryptoAmount,
		&i.FiatAmount,
		&i.BankName,
		&i.AccountNumber,
		&i.AccountHolder,
		&i.Rate,
		&i.IsAccepted,
		&i.IsCompleted,
		&i.IsRejected,
		&i.IsReceived,
		&i.Duration,
		&i.CreatedAt,
	)
	return i, err
}

const getOrders = `-- name: GetOrders :many
SELECT id, username, escrow_address, user_address, order_type, crypto, fiat, crypto_amount, fiat_amount, bank_name, account_number, account_holder, rate, is_accepted, is_completed, is_rejected, is_received, duration, created_at FROM orders
WHERE username = $1
ORDER BY id
`

func (q *Queries) GetOrders(ctx context.Context, username string) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrders, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.EscrowAddress,
			&i.UserAddress,
			&i.OrderType,
			&i.Crypto,
			&i.Fiat,
			&i.CryptoAmount,
			&i.FiatAmount,
			&i.BankName,
			&i.AccountNumber,
			&i.AccountHolder,
			&i.Rate,
			&i.IsAccepted,
			&i.IsCompleted,
			&i.IsRejected,
			&i.IsReceived,
			&i.Duration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrders = `-- name: GetUserOrders :many
SELECT id, username, escrow_address, user_address, order_type, crypto, fiat, crypto_amount, fiat_amount, bank_name, account_number, account_holder, rate, is_accepted, is_completed, is_rejected, is_received, duration, created_at FROM orders
WHERE user_address = $1
ORDER BY id
`

func (q *Queries) GetUserOrders(ctx context.Context, userAddress string) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getUserOrders, userAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.EscrowAddress,
			&i.UserAddress,
			&i.OrderType,
			&i.Crypto,
			&i.Fiat,
			&i.CryptoAmount,
			&i.FiatAmount,
			&i.BankName,
			&i.AccountNumber,
			&i.AccountHolder,
			&i.Rate,
			&i.IsAccepted,
			&i.IsCompleted,
			&i.IsRejected,
			&i.IsReceived,
			&i.Duration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :exec
UPDATE orders
SET
  escrow_address = COALESCE($1, escrow_address),
  user_address = COALESCE($2, user_address),
  order_type = COALESCE($3, order_type),
  crypto = COALESCE($4, crypto),
  fiat = COALESCE($5, fiat),
  crypto_amount = COALESCE($6, crypto_amount),
  fiat_amount = COALESCE($7, fiat_amount),
  rate = COALESCE($8, rate),
  is_accepted = COALESCE($9, is_accepted),
  is_completed = COALESCE($10, is_completed),
  is_rejected = COALESCE($11, is_rejected),
  is_received = COALESCE($12, is_received),
  duration = COALESCE($13, duration)
WHERE 
  id = $14
  AND username = $15
`

type UpdateOrderParams struct {
	EscrowAddress sql.NullString  `db:"escrow_address" json:"escrow_address"`
	UserAddress   sql.NullString  `db:"user_address" json:"user_address"`
	OrderType     sql.NullString  `db:"order_type" json:"order_type"`
	Crypto        sql.NullString  `db:"crypto" json:"crypto"`
	Fiat          sql.NullString  `db:"fiat" json:"fiat"`
	CryptoAmount  sql.NullFloat64 `db:"crypto_amount" json:"crypto_amount"`
	FiatAmount    sql.NullFloat64 `db:"fiat_amount" json:"fiat_amount"`
	Rate          sql.NullFloat64 `db:"rate" json:"rate"`
	IsAccepted    sql.NullBool    `db:"is_accepted" json:"is_accepted"`
	IsCompleted   sql.NullBool    `db:"is_completed" json:"is_completed"`
	IsRejected    sql.NullBool    `db:"is_rejected" json:"is_rejected"`
	IsReceived    sql.NullBool    `db:"is_received" json:"is_received"`
	Duration      sql.NullTime    `db:"duration" json:"duration"`
	ID            int64           `db:"id" json:"id"`
	Username      string          `db:"username" json:"username"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateOrder,
		arg.EscrowAddress,
		arg.UserAddress,
		arg.OrderType,
		arg.Crypto,
		arg.Fiat,
		arg.CryptoAmount,
		arg.FiatAmount,
		arg.Rate,
		arg.IsAccepted,
		arg.IsCompleted,
		arg.IsRejected,
		arg.IsReceived,
		arg.Duration,
		arg.ID,
		arg.Username,
	)
	return err
}
